■PART001 – 자기소개
- ● [TOP] 1분 자기소개  - 이력서 바탕
- 나를 한 단어로 표현  
- 나의 경험 (지원동기, 성공 경험)  
- 입사 후 포부  

■PART002 – 인성면접
- 회사를 지망한 동기  
- 우리 회사에 불합격한다면 어떻게?  
- 무엇을 기준으로 회사 선택  
- 왜 우리 회사와 일하고 싶은지  
- ● [TOP] 마지막으로 하고 싶은 말  - 지금프로젝트, 근무환경, 실제 사용하는 기술스택,,,, 
- 우리 회사에 대해 알고 있는 점  

■PART003 – 기본 CS/Java
- 객체지향프로그래밍이란?
> 현실세계의 개념을 객체 단위로 모델링해 재사용성과 유지보수성을 높이기 위한 프로그래밍입니다.
> 절차지향에 비해 객체지향은 재사용성이 높고 모듈화에 유리합니다
> 4대 특성으로는 캡슐화, 추상화, 상속, 다형성이 있습니다.

- 객체지향의 4대 특성   
> 객체지향의 4대 특성은 캡슐화, 추상화, 상속, 다형성을 꼽을 수 있습니다.

> 캡슐화는 데이터와 메서드를 하나로 묶는 것으로 접근제어자와 getter/setter를 통해 외부 접근을 제어합니다.
> 실제 프로젝트에서는 클래스 변수를 private으로 설정하고 gettter/setter, 롬복을 이용해 접근하였습니다.

> 추상화는 핵심 개념만 표현하여 복잡도를 줄이고 불필요한 세부 구현을 숨기는 방식으로 인터페이스나 추상클래스로 구현합니다.

> 상속은 기존 클래스의 기능을 재사용하고 확장하기 위한 구조입니다.

> 다형성은 동일한 인터페이스를 기반으로 다양한 구현체를 사용할 수 있게 하며 유연한 확장과 유지보수가 가능합니다.

- JVM의 역할   
> JVM은 자바 파일을 운영체제에 구애받지 않고 다양한 환경에서 동일하게 실행할 수 있게 해주는 가상 환경입니다.
> GC를 이용하여 효율적인 메모리 관리가 가능합니다.
> 구성으로는 가상 환경인 JVM과 실행 환경인 JRE, 개발 도구인 JDK가 있습니다.

- 자바의 메모리 구조  
> 메서드 영역과 힙, 스택, PC레지스터, 네이티브메서드가 있습니다.
> 힙 영역에서는 동적으로 객체를 저장하고 스택 영역에서는 메서드를 호출하고 지역변수를 저장합니다.

- 오버로딩 vs 오버라이딩  
> 오버로딩은 메서드명은 동일하지만 파라미터의 타입이나 개수를 다르게 사용할 수 있습니다.
> 오버라이딩은 상속을 통해 구현하는 것으로 파라미터 타입과 개수가 일치해야 하며 반드시 구현해야 합니다. 

- 다형성이란?  
> 다형성은 동일한 인터페이스를 기반으로 다양한 구현체를 사용하는 것을 의미합니다.
> 예를 들어 부모 타입으로 여러 자식 객체를 참조하고 오버라이딩된 메서드가 동적으로 호출되는 구조 등이 대표적입니다.
> (프로젝트 내 예시 보충할 것)

- 인터페이스란?  
> 인터페이스는 구현체가 없는 일종의 설계도로 객체가 가져야 할 동작을 정의한 것입니다. 
> 메서드 구현 없이 시그니처만 선언하여 해당 클래스가 반드시 구현하도록 합니다.

- 추상 클래스 vs 인터페이스  
> 추상 클래스는 공통 기능과 상태를 일부 구현체와 공유하기 위한 목적이고 단일 상속만 가능합니다.
> 인터페이스는 다중 구현이 가능하며 다형성 중심 설계에 적합합니다.

- 접근 제어자  
> 접근 제어자는 클래스, 변수, 메서드 등에 대한 접근 범위를 제한합니다.
> 자바에서는 public, protected, default, private 등이 있습니다.
> public은 모든 접근을 허용하고 protected는 상속 관계에서 접근을 허용합니다.
> default는 같은 패키지 내에서, private은 같은 클래스 내의 접근만 허용합니다.

- 컬렉션 프레임워크란  
> 배열의 단점을 보완해 데이터를 관리하기 위한 자바 표준 라이브러리로 List / Set / Map 같은 인터페이스를 중심으로 구성되어 있습니다.
> 배열은 크기가 정해져 있어 확장하기 번거롭지만 동적 배열인 컬렉션 프레임워크는 한계 없이 저장이 가능합니다.

- ● List / Set / Map 차이  
> List는 순서가 있고 중복을 허용합니다.
> Set은 순서가 없고 중복이 허용되지 않습니다.
> Map은 key와 value가 짝을 이루는 구조로 key값은 중복이 불가능합니다.

- 제네릭이란  
> 컬렉션 프레임워크에서 타입을 일반화하기 위해 사용합니다.
> 불필요한 형 변환을 줄여 코드의 재사용성과 가독성이 높아집니다.

- Wrapper Class란  
> 컬렉션 프레임워크 같은 객체만 지원하는 환경에서 기본 자료형을 객체로 사용할 수 있도록 래핑하는 클래스입니다.
> 기본 자료형 :  byte-short-int-long, float-double, boolean

- ● 프로세스란  
> 현재 실행되고 프로그램에서 독립된 메모리 공간을 할당받아 동작하는 작업의 단위를 의미합니다.

- ● 스레드란  
> 프로세스 내부에서 실행되고 있는 흐름의 단위를 의미합니다.
> 같은 프로세스의 메모리를 공유하며 병렬 처리를 수행합니다. 

- 스레드 구현 방법  
> 자바에서 스레드를 구현하는 방법은 두 가지가 있습니다.
> 첫 번째는 스레드를 상속받아 run() 메서드를 구현하는 것이고
> 두 번째는 runnable 인터페이스를 구현하여 스레드 객체에 전달하는 방식입니다.
> 일반적으로 자바는 단일 상속 구조기 때문에 확장성을 위해 다중 상속이 가능한 runnable 구현 방식이 더 많이 사용됩니다.

- 데드락(Deadlock)이란  
> 여러 스레드가 서로 점유한 자원을 기다리며 교착 상태에 빠지는 것을 의미합니다. 
> 자원 순서를 정하거나 타임아웃 설정으로 예방할 수 있습니다.

- ● TCP vs UDP  
> TCP는 연결 지향 방식으로 순서가 보장되고 신뢰성 있는 통신을 제공합니다. 1:1 채탕 같은 기능에 적합합니다.
> UDP는 비연결 지향 방식으로 속도가 빠르지만 순서를 보장하지 않고 어느 정도의 데이터 손실이 발생할 수 있습니다. 실시간 스트리밍 등에 적합합니다.

- 채팅 구현 시 사용 패키지  
> 자바 패키지의 경우 java.net, java.io를 사용했습니다.
> 구체적인 클래스로는 Socket, ServerSocket이 있습니다. 

- ● 싱글톤 패턴이란  
> 애플리케이션 내에서 객체를 하나만 생성해 공유하는 방식입니다.
> 주로 공통 자원 관리나 설정 객체처럼 하나의 객체만 필요한 경우에 사용합니다.
> 저희 프로젝트에선느 리액트의 리덕스나 스프링의 빈을 예시로 들 수 있습니다.

- 예외 처리 예제  
> try-catch-finally 예제

- 구구단 프로그램작성  
> 이중 for 이용

- ArrayList vs LinkedList  
> ArrayList는 순서가 존재해 인덱스를 통한 조회 속도가 빠릅니다.
> LinkedList 노드 간 연결 구조로 데이터를 저장해 삽입과 삭제 등에 유리합니다.

- 컴파일러 vs 인터프리터  
> 컴파일러는 전체 소스 코드를 한 번에 기계어나 중간 코드로 변환한 뒤 실행하는 방식이고
> 인터프리터는 코드를 한 줄씩 해석하여 즉시 실행하는 방식으로 자바스크립트에서 활용합니다.   

- 자바 빌드 자동화 툴  
> 자바 빌드 자동화 툴은 프로젝트의 컴파일, 테스트 패키징, 의존성 관리 등을 자동으로 실행하는 도구입니다.
> 대표적으로 Maven과 Gradle이 있고 3차 프로젝트에선 Maven을, 4차에선 Gradle을 사용했습니다.

- Gradle vs Maven
> 메이븐은 xml 기반의 pom.xml을 사용하며 표준화된 구조로 이해가 쉬운 반면
> 그래들은 스크립트 기반으로 설정이 유연하고 빌드 속도가 빠른 특징이 있습니다.

- 자바 테스트 자동화 툴  
> 자바 테스트 자동화 툴로는 JUNIT이 있습니다.       
> 단위 테스트를 작성하고 자동 실행할 수 있도록 지원해 조기에 오류를 발견할 수 있습니다.

- final / static / abstract 키워드  
> final은 변경이나 재정의를 제한하는 키워드로 변수의 값 변경 금지, 메서드의 오버라이딩 금지, 클래스에서는 상속 금지를 의미합니다.
> static은 클래스 수준에서 공유되는 요소를 의미하며 객체 생성 없이 접근이 가능하고 모든 인스턴스가 값을 공유합니다.
> abstract은 공통 동작의 틀을 정의하기 위한 키워드로 추상 메서드는 구현 없이 선언만 하고 하위 클래스에서 반드시 구현하도록 합니다.

- Call by Value vs Reference  
> Call by Value는 값을 복사해 가져오는 것으로 값을 변경해도 원본에 영향을 미치지 않습니다.
> Reference는 메모리 위치를 참조하는 것으로 같은 대상을 가리키는 것이기 때문에 변경 시 원본 값에도 영향을 미칩니다.
> 자바에서는 Call by Value를 지원합니다.

- JVM 구성 요소  
> JVM은 자바 프로그램을 실행하기 위한 환경으로 크게 클래스 로더, 메모리 영역, 실행 엔진으로 구성됩니다.
> 클래스 로더는 컴파일된 바이트코드 파일을 JVM 메모리에 적재하는 역할을 합니다.
> 적재된 데이터는 메모리 영역에서 관리되는데 클래스 정보와 static 데이터는 method 영역에 저장되고 생성된 객체는 heap 영역에 저장됩니다. 
> 메서드 실행 과정에서 사용하는 지역변수와 호출 정보는 stack 영역에서 관리됩니다.
> 이후 실행 엔진이 바이트코드를 해석하거나 컴파일을 통해 실행되며 heap 영역에 생성된 객체 중 더 이상 사용되지 않는 것은 garbage collector가 자동으로 정리합니다.

- ● RESTful 설계 조건  
> RESTful는 URL로 자원을 표시하고 HTTP 메서드로 상태를 구분하는 API 설계 방식입니다.
> 또한 서버가 상태를 저장하지 않는 무상태성과 일관된 인터페이스를 유지하는 특성이 있습니다.

- ● 주요 Spring 어노테이션  
> @Autowired : 스프링 컨테이너가 관리하는 객체를 자동으로 주입
> @Service : 비즈니스 로직 담당
> @Mapper : Mybatis 사용 시 메퍼 인터페이스 등록
> @RestController : REST API 컨트롤러 선언, 반환값을 JSON 형태로 응답
> @RequestMapping : URL 요청 경로와 HTTP 메서드를 매핑
> @Component : 스프링이 관리할 일반 컴포넌트 빈 등록 (기본 스캔 대상)
> @ResponseBody : 반환값을 View가 아닌 HTTP 응답 본문(JSON 등)으로 전달
> @RequestParam : HTTP 요청 파라미터 값을 메서드 인자로 바인딩

- RestController vs Controller
> @Controller는 주로 화면을 반환하는 데 사용됩니다.
> @RestController는 @Controller와 @ResponseBody가 결합된 형태로 객체 데이터를 JSON 형태로 HTTP 응답 본문에 직접 반환합니다.

- ● JPA 지연 vs 즉시 로딩  
> JPA에서 지연 로딩과 즉시 로딩은 연관 엔티티를 언제 조회할지 결정하는 방식의 차이입니다.
> 즉시 로딩은 엔티티 조회 시 연관 엔티티를 함께 조회하는 방식이고
> 지연 로딩은 실제 해당 엔티티를 사용할 때 추가 조회하는 방식입니다. 

- ● JWT 인증 구성  
> AccessToken과 RefreshToken을 분리해 인증을 관리합니다.

■PART004 – 프로젝트 (2) 
- ● Spring Boot의 장점  
> 스프링부트는 스프링에 비해 의존성 주입을 통한 환경 설정과 내장 톰캣을 지원합니다.
> 따라서 환경설정 부담이 적고 일관된 환경에서 빠른 작업을 가능하게 해 협업 환경에서 유리합니다. 

- ● Spring Security에서 인증과 인가 차이점 (중복)  
> 인증은 사용자의 신원을 확인하는 과정이고 인가는 인증된 사용자의 접근 권한을 검증하는 과정입니다. 
> 프로젝트에서는 Role 기반 접근 제어를 적용해 사용자 권한에 따라 API 접근을 제한했습니다.(인가)

- ● JPA vs MyBatis 차이점 (중복)  
> JPA는 객체와 데이터베이스 테이블을 매핑해 기본적인 SQL 작성 없이 기본적인 CURD를 사용할 수 있어 효율적이지만 복잡한 SQL 구문 작성에 한계가 있습니다.
> 반면 Mybatis는 SQL을 일일이 작성해야 하는 대신 세밀한 조정이 가능해 성능을 높이거나 복잡한 쿼리에 유리합니다.
> JPA는 객체 중심, Mybatis는 SQL 중심으로 정리할 수 있습니다.

- Thymeleaf의 특징 (중복)  
> 타임리프는 서버사이드 템플릿 엔진으로 html 문서를 기반으로 동작합니다. 

- SSR vs CSR
> 서버사이드 템플릿은 서버가 화면을 생성하는 것이고
> 클라이언트사이드 템플릿은 브라우저가 화면을 생성하는 것입니다.

- ● AWS에서 배포 시 고려사항  
> AWS를 배포할 때 보안과 네트워크 구성, 서버 운영 측면을 함께 고려해야 한다고 생각합니다.
> 예를 들어 리버스 프록시 사용으로 포트의 직접적인 노출을 방지할 수 있고
> 환경변수를 사용해 민감정보를 분리할 수 있습니다.
> 또한 로그 모니터링과 프로세스 관리, 인스턴스 자원 등을 선택해 안정적인 서비스 운영이 가능하도록 해야 합니다.
> auto scaling과 예약 인스턴스 활용해 비용 최적화를 고려해볼 수도 있습니다.

- ● React에서 상태 관리 방법 (중복)  
> useState와 useReact, Redux 등이 있습니다.
> useState로 컴포넌트 내부 상태를 관리하고
> 복잡한 상태 로직은 useReact를 사용할 수 있습니다.
> 여러 컴포넌트에서 상태를 공유할 경우 Redux같은 전역 상태 관리 방식을 사용합니다.

- 반응형 웹 구현 시 고려사항  
> 반응형 웹 구현 시 다양한 화면 크기에 대응할 수 있도록 해야 합니다.
> 모바일을 비롯해 작은 화면에서도 버튼이나 텍스트가 깨져 가독성이 떨어지지 않도록 
> 미디어쿼리와 유연한 레이아웃을 활용해 활용 크기에 따라 스타일을 조절합니다.
> 포트폴리오에서는 그리드 레이아웃을 활용한 바 있습니다.

- 크로스 브라우징 이슈 해결 방법  
> 크로스 브라우징은 다양한 브라우저 환경에서 동일한 동작과 화면을 보장하는 것이며 
> 이를 위해 웹 표준을 준수하고 브라우저 호환성 테스트를 수행할 수 있습니다. 
> 필요에 따라 css 프리픽스 적용 등으로 기능 지원 차이를 보완할 수 있고
> 표준 api를 사용하거나 babel 활용할 수 있습니다.

- 배포 이슈 해결 경험  
> AWS EC2를 통한 배포 시 일부 환경변수와 일부 엔티티가 누락되는 경험을 했습니다.
> 누락 지점을 찾아 환경변수 파일을 직접 EC2에 등록하고 로컬 DB를 EC2 DB로 이관하여 해결했습니다. 

- 복잡한 로직 처리 시 고려한 점  
> 복잡한 로직을 처리할 때 사용자 흐름과 가독성을 우선적으로 고려했습니다.
> 예를 들어 프로젝트에서 외부 API를 활용하는 기능을 구현했을 때 
> 사용자가 입력한 자연어를 기반으로 API가 필요한 필터를 변경한 뒤 상세 필터 토글 창을 자동으로 열어주는 흐름을 구성했습니다.
> 이 과정에서 상태 변경 순서가 어긋나면 UI가 불안정해질 수 있어 동작 순서에 따라 단계별로 작동하도록 조정하고
> 상태 갱신과 랜더링이 안정적으로 이루어지도록 하였습니다

- 사용자 피드백 반영 경험  
> 실제 사용자 피드백을 받아본 경험은 없지만 팀 프로젝트 진행 중 관리자 전용 메뉴바를 분리했으면 좋겠다는 의견을 받은 적이 있습니다.
> 메뉴바에서 관리자 메뉴를 묶고 호버 시 드롭다운 되는 형식으로 UI를 개선하여 사용 편의성을 높였습니다.

- 실용적인 기능 구현 예시  
> 사료 필터 기능을 구현할 때 단순히 브랜드나 그레인프리같은 단순 필터뿐만 아니라 영양 상세 필터도 추가하였습니다.
> 주요 영양소별로 2단계에서 3단계로 나누고 고단백, 저단백, 저지방 같은 직관적인 라벨을 붙였고 
> 검색 결과를 통해 상세 정보를 확인하고 사용자 후기도 제공하여 사용 편의성을 높였습니다.
> 라벨의 경우 반려동물 영양학 전문 서적을 참고하여 기준을 정했습니다.

- SI/SM 프로젝트에서 중요했던 점  
> 전반적인 흐름, 대용량 데이터 처리 경험, 표준화, 안정성

- 웹/앱 에이전시에서 중요했던 점  
> 단기간 내 결과물, 프로젝트마다 요구되는 기술이 달라 빠른 학습과 적응력 필요

- 스타트업/벤처에서 중요했던 점  
>빠른 대응, 최소 기능 제품 개발 

- 프로젝트 개발 순서  
> 저희 팀 프로젝트는 기획회의를 거친 뒤 요구사항을 정의하고 DB 설계를 진행하며 구조를 정리했습니다.
> 이후 백엔드를 먼저 구현하고 프론트엔드와 연결한 뒤
> 테스트와 피드백을 거쳐 기능을 안정화하는 순서로 진행했습니다.

- SI란?  
> 고객의 요구사항에 맞춰 시스템을 개발하고 기존 환경과 통합해 제공하는 형태의 프로젝트를 의미한다고 알고 있습니다.

- SW 개발에서 가장 비중을 둬야 하는 단계  
> 요구사항 분석과 설계 단계라고 생각합니다.
> 먼저 요구사항을 명확하게 분석한 뒤 설계를 탄탄히 해야 개발 과정에서의 시행착오를 줄일 수 있고 협업이 원활하게 이루어지기 때문입니다.

- 애자일 방법론이란  
> 에자일 방법론은 개발 과정을 작은 단위로 나누어 반복적으로 기능을 개발하고 피드백을 반영해 개선해나가는 것을 의미합니다.
> 변화에 유연하게 대처할 수 있고 팀 협업과 지속적인 소통이 중요합니다.

- @SpringBootApplication의 역할  
> 스프링의 구동 시작점으로 자동 설정과 컴포넌트 스캔 등을 활성화해 전체 구성을 간소화하는 역할을 합니다.
> @Configuration, @ComponentScan, @EnableAutoConfiguration 등의 복합 어노테이션을 사용합니다.

- Spring Security 필터 체인이란 (중복)  
> 요청 시 인증과 인가 과정을 처리하는 필터들의 연속된 구조로 순차적인 보안 검증을 수행합니다.

- JPA Entity란 (중복)  
> 데이터베이스 테이블과 매핑되는 자바 클래스입니다.

- ● JPA 영속성 컨텍스트란 
> 엔티티를 저장하면 영속성 컨텍스트에 등록하고 상태 변화를 자동으로 DB에 반영하는 역할을 합니다.

- MyBatis에서 #{} vs ${} 차이점 (중복)  
> #{ }는 PreparedStatement 바인딩 방식을 사용해 값을 안전하게 전달하며 SQL Injection을 방지합니다.
> 반면 ${ }는 문자열을 직접 치환하는 방식으로 보안 위험이 있어 동적 테이블이나 컬럼명 같은 경우에 사용됩니다.
 
- Thymeleaf에서 th:if와 th:each (중복)  
> if는 조건문에서 사용하고 each는 반복문에서 사용합니다.

- ● AWS EC2 vs S3 차이점  
> EC2는 가상 서버 환경을 제공하는 클라우드 서버로 애플리케이션을 실행하거나 배포합니다. 
> S3는 파일이나 정적 데이터를 저장하는 저장소 역할을 합니다.

- ● CI/CD란  
> CI는 코드 변경 시 자동으로 빌드와 테스트를 해주며 
> CD는 검증된 결과물을 자동으로 배포까지 연결하는 것입니다. 

>CI/CD 파이프라인 - 코드 변경 시 자동으로 빌드와 테스트를 진행하며 검증된 결과물을 자동으로 배포해주는 자동화 파이프라인을 의미합니다.

- ● React에서 컴포넌트 분리 기준 (중복)  
> React 컴포넌트 분리는 재사용성과 역할 단일 책임을 기준으로 판단했습니다.
> 여러 화면에서 반복 사용되는 UI나 로직은 공통 컴포넌트로 분리해 중복을 줄였고
> 기능 단위로 상태와 책임을 명확히 나누어 유지보수성을 높였습니다.
> 또한 페이지 컴포넌트가 과도하게 비대해지지 않도록 UI와 로직을 하위 컴포넌트로 분리해 가독성과 확장성을 확보했습니다.

- ● React에서 useEffect는 언제 사용하나요? (중복)  
> useEffect는 화면이 랜더링된 후 실행해야 하는 작업을 처리할 때 사용합니다.
> 주로 초기 API 호출이나 상태 변경에 따른 추가 작업이 필요할 때 활용했습니다.
> 프로젝트에서는 게시판 목록을 호출하거나 검색 조건이 바뀔 때 데이터를 다시 조회하는 용도로 사용했습니다.

- ● Git 협업 시 주의사항  
> Git 협업 시에는 작업 브랜치와 메인 브랜치가 섞이지 않도록 관리하는 것을 중요하게 생각합니다.
> 기능 단위로 브랜치를 분리해 작업하고, PR 전에 변경 내용을 다시 확인해 충돌 가능성을 점검했습니다.
> 또한 merge 시 충돌 지점을 꼼꼼히 검토하고 다른 작업에 영향을 주지 않는지 확인하는 점에 주의했습니다.

- ● API 명세 관리 방법  
> 별도의 명세 관리 도구를 사용하지 않았지만 Swagger를 통해 API 스펙을 확인하고 테스트했습니다.
> 요청 URL, 파라미터, 응답 구조를 확인하며 연동을 진행했고 변경 사항 발생 시 팀원 간 공유하며 작업했습니다.

- ● 테스트 코드 작성 고려사항  
> 의도한 기능이 제대로 동작하는지 확인하는 것을 우선시 했습니다.
> 정상동작뿐 아니라 예외 상황이나 경계값도 함께 검증하기 위해 노력했고
> 테스트 간 의존성이 생기지 않도록 독립적으로 실행 가능하도록 구성했습니다.

- 프로젝트 성능 개선 경험  
> AI 기능 구현 과정에서 초기에는 전체 DB 데이터를 프롬프트에 포함시키려고 했으나 토큰 사용량이 과다하게 증가하는 문제가 발생했습니다.
> 이를 해결하기 위해 LISTAGG를 사용해 컬럼별로 존재하는 항목만 집계하도록 구조를 변경하였습니다.
> 그 결과 불필요한 데이터 전달을 줄여 처리 비용을 감소시키고 빠르고 안정적인 응답이 가능해졌습니다. 

- 협업 도구 사용 경험  
> 깃허브를 통해 팀 프로젝트 버전 관리와 협업을 수행했고 
> 구글시트와 피그마를 사용해 역할 분담과 진척 상황을 관리하며 실시간으로 정보를 공유해나갔습니다.

- 장애 대응 경험  
> 배포 과정에서 서버 환경변수가 적용되지 않아 API가 정상 동작하지 않는 장애를 경험했습니다.
> 로그와 설정을 점검하며 원인을 확인했고 서버 환경변수를 직접 구성해 문제를 해결했습니다.

- ● 웹사이트 최적화 방법  
> 웹사이트 최적화를 위해 불필요한 API 호출이나 렌더링을 줄이고 데이터 요청을 효율적으로 구성하는 것을 우선 고려합니다.
> 또한 이미지 용량 최적화나 코드 분리 등을 통해 초기 로딩 부담을 줄이는 방법을 적용할 수 있습니다.
> 상황에 따라 캐싱이나 페이징 처리 등을 통해 서버 부담을 줄이는 것도 중요하다고 생각합니다.

- 웹사이트 성능 측정 도구  
>웹사이트 성능 측정에는 Chrome DevTools의 Network 탭이나 Lighthouse를 활용해 로딩 시간과 리소스 크기를 확인할 수 있습니다.

- npm이란  
> npm은 Node.js 환경에서 사용하는 패키지 관리자입니다.
> 라이브러리나 의존성을 설치하고 버전을 관리하며 프로젝트에서 필요한 모듈을 쉽게 사용할 수 있도록 도와주는 도구입니다.

- package.json의 역할
> package.json은 Node.js 프로젝트의 설정 파일로 프로젝트에 필요한 패키지 의존성과 버전, 실행 스크립트 등을 관리하는 역할을 합니다.
> 이를 통해 동일한 환경을 재현하고 프로젝트 구성을 공유할 수 있습니다.  

- React 생명주기 처리 방법 (중복)  
- React에서 key props의 역할 (중복)  
- 상태 끌어올리기란 (중복)  
- React Router란 (중복)  
- Redux란 (중복)  
- Node.js의 동기 vs 비동기 처리 (중복)  
- Express.js에서 미들웨어란 (중복)  
- ● MongoDB vs MySQL 차이점  
- ● CORS란  
- ● 브라우저의 렌더링 과정  
- ● HTTPS란  
- ● SSL 인증서란  
- 서버 사이드 vs 클라이언트 사이드  
- ● 프로세스 vs 스레드  
- Git 기본 명령어  
- ● Git merge vs rebase 차이점  
- 배포란  
- 배포 도구 예시  
- ● CI/CD란  
- ● SPA의 단점  
- MPA란  
- ● Next.js란  
- ● Webpack이란  
- ● Babel이란  
- ● TypeScript란


■PART005 – 프로젝트 (3)
- ● MVC Model1 vs Model2 차이점  
- ● Servlet vs JSP 차이  
- ● WS vs WAS 차이  
- 동기 vs 비동기  
- ● Ajax란  
- Ajax 파일 형식  
- ● XML vs JSON 차이  
- 웹서버 동작 방식  
- Request / Response 정의  
- Request Method 종류  
- ● RESTful이란  
- ● API란  
- ● 쿠키 vs 세션  
- ● 프레임워크 vs 라이브러리  
- Spring 환경설정  
- ● Spring MVC 흐름  
- ● IoC란  
- ● DI란  
- DI 주입 방식  
- ● Bean이란  
- ● AOP란  
- ● Transaction(TX)이란  
- MyBatis란 (중복)  
- JDBC란  
- DBCP란  
- Statement vs PreparedStatement  
- ● JPA란 (중복)  
- ● Node.js란 (중복)  
- Node.js 특징  
- Express.js란 (중복)  
- ● React란 (중복)  
- ● React 주요 Hook (useState/useEffect/useContext) (중복)  
- ● React 상태 관리 방법 (중복)  
- ● JWT란 (중복)  
- JWT 구조 (중복)  
- JWT 인증 흐름 (중복)  
- ● Access Token vs Refresh Token (중복)  
- ● JWT 보안 이슈 (중복)  
- ● CSR이란  
- ● SSR이란  
- ● CSR vs SSR 차이  
- ● React vs Vue 차이  
- ● JSX란  
- ● Virtual DOM이란  
- ● 컴포넌트란 (중복)  
- ● Props vs State (중복)  
- ● SPA란  
- ● SEO 최적화 (React)

■ PART006 – ORACLE
- ● JDBC  
- ● DBCP  
- ● Statement vs PreparedStatement  
- MyBatis Mapper  
- ● DBMS / RDBMS  
- ● SQL 분류 (DDL, DML, DCL)  
- ● DDL  
- ● DML  
- ● DCL  
- ● 정규화  
- ● ERD  
- ● DROP vs DELETE vs TRUNCATE  
- ● WHERE vs HAVING  
- ● 집계함수 종류  
- ● 서브쿼리  
- ● 조인 종류  
- ● 서브쿼리 vs 조인 차이  
- ● 트랜잭션  
- 뷰(View)  
- 데이터 사전  
- ● 인덱스  
- JOIN 문제 예제 (평균, 특정 행 조회, JOIN, LEFT OUTER JOIN)  
- ● 기본키(Primary Key)  
- ● 외래키(Foreign Key)  
- ● UNIQUE  
- ● NOT NULL  
- ● AUTO_INCREMENT  
- ● CHAR vs VARCHAR  
- ENUM vs SET  
- ● 인덱스 단점  
- 트리거  
- 뷰 장점  
- ● GROUP BY  
- ● IN vs EXISTS   
- 사용자 생성  
- 권한 부여

■PART007 – Linux + AWS
Linux 기본 명령어  
- Hello world 스크립트 작성  
- 현재 프로세스 나열  
- start.sh 실행 모드 변경  
- 디렉토리 이동 및 톰캣 종료  
- ● 리눅스 IP 주소 확인  
- ● 현재 경로 확인  
- ● 디렉토리 목록 보기  
- ● 파일 내용 보기  
- ● 파일 검색  
- ● 파일 복사/이동/삭제  
- ● 디스크 사용량 확인  
- ● 메모리 사용량 확인  
- ● 파일 권한 변경  
- ● 소유자 변경  
- ● 백그라운드 실행  
- ● 포트 사용 확인  
- ● 서비스 시작/중지  
- ● crontab 등록  
- ● 로그 확인  
- ● 사용자 추가/삭제  

AWS 관련  
- ● AWS란?  
- ● EC2란?  
- ● S3란?  
- ● RDS란?  
- ● VPC란?  
- ● IAM이란?  
- AMI란?  
- ● Auto Scaling이란?  
- ● CloudWatch란?  
- ● ELB란?  
- AWS CLI란?  
- S3 버킷 생성 명령어  
- EC2 인스턴스 시작 명령어  
- ● 보안 그룹이란?  
- ● 키 페어란?  
- ● 데이터 백업 방법  
- ● 비용 절감 방법  
- ● Lambda란?  
- ● CloudFormation이란?  
- ● Route 53이란?  
- ● 리버스프록시  

MSA 관련  
- ● MSA란 무엇인가요?  
- ● MSA의 장점  
- ● MSA의 단점  
- ● MSA에서 API Gateway 역할  
- ● MSA에서 서비스 간 통신 방식  
- ● MSA에서 데이터베이스 구성  
- ● MSA에서 장애 복구 전략  
- ● MSA에서 서비스 디스커버리란?  
- ● MSA에서 CI/CD 파이프라인 구성  
- ● MSA에서 모니터링 도구  

Redis 관련  
- ● Redis란 무엇인가요?  
- ● Redis를 사용하는 이유는?  
- ● Redis에서 캐시 무효화 처리 방법  
- ● Redis와 Memcached 차이점  
- ● Spring에서 Redis 캐싱 사용하는 방법  
- ● Redis Pub/Sub은 언제 사용하나요?  
- ● Redis와 RDBMS를 함께 사용하는 이유


■PART008 – 최신 추가 공통 질문
객체지향/설계 원칙
- ● SOLID 원칙 (SRP, OCP, LSP, ISP, DIP)  
- ● 디자인 패턴 (싱글톤, 팩토리, 옵저버, 전략 등)  
- 캡슐화/상속/다형성/추상화의 실제 적용 사례  

최신 기술/도구 활용
- GPT 활용법 (코드 작성, 문서 요약, 아이디어 브레인스토밍 등)  
- ● CI/CD 파이프라인 구성 경험 (GitHub Actions, Jenkins 등)  
- ● API 명세 관리 방법 (Swagger, Postman 등)  
- ● 테스트 자동화 도구 활용 (JUnit, Jest, Cypress 등)  

네트워크/보안
- ● CORS란 무엇인가?  
- ● HTTPS와 SSL 인증서의 역할  
- ● JWT 보안 이슈 및 대응 방법  
- ● Access Token vs Refresh Token 관리 전략  

데이터베이스/성능
- ● JPA 영속성 컨텍스트  
- ● MyBatis #{} vs ${} 차이점  
- ● 인덱스 단점 및 최적화 전략  
- ● 캐시 무효화 처리 방법 (Redis 등)  

프론트엔드/웹
- ● CSR vs SSR 차이점  
- ● SEO 최적화 방법 (React 등)  
- ● React Router, Redux, 상태 끌어올리기  
- ● 브라우저 렌더링 과정  

운영체제/인프라
- ● Linux crontab, 로그 관리, 사용자 관리  
- ● AWS 비용 절감 방법  
- ● MSA 장애 복구 전략 및 서비스 디스커버리  
- ● Redis Pub/Sub 활용 사례  

인성/시사
- ● 블라인드 채용에 대한 의견  
- ● 최근 국제 뉴스에서 관심 있는 주제  
- ● 4차 산업혁명과 일자리 변화  
- ● 향후 5년간 국가적 중요 이슈  

■ PART009 – 각 산업군별 
공통 질문  
- ● 최근에 배운 기술 중 실무에 적용한 사례는?  
- ● 프로젝트에서 가장 큰 기술적 도전은 무엇이었나요?  
- ● 비개발자와 협업 시 의사소통 문제는 없었나요?  
- ● 테스트 자동화와 품질 관리를 어떻게 했나요?  
- ● 이직/취업 후 가장 먼저 하고 싶은 기술적 시도는?  

SI / SM  
- ● 시스템 장애 발생 시 어떻게 대응했나요?  
- ● 유지보수하기 좋은 코드를 위해 어떤 기준을 두었나요?  

솔루션 개발사  
- 특정 도메인에 대한 학습/이해도 강조  
- ERP/그룹웨어/보안 도메인 기능 설계 경험  
- ● 사용자 요구사항을 기능에 반영한 사례  

웹/앱 에이전시  
- ● 반응형 UI 구현 시 사용한 기술 및 어려웠던 점  
- ● 클라이언트와 마감이 촉박할 때 어떻게 대처했나요?  

스타트업/벤처  
- ● 새로운 기술을 급하게 습득해 적용한 사례  
- ● MVP 프로토타입 제작 후 사용자 피드백 반영 경험  

인하우스 개발팀  
- ● 실사용자 피드백 반영 과정  
- ● 사내에서 가장 많이 쓰이는 기능을 왜 그렇게 구현했나요?



