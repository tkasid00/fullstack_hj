**정리**

#1. FAQ 게시판 
 - 스크립트 사용x 단순 정보 게시용 기초 curd 게시판.
 - 리스트 페이지를 고객센터 메인 페이지로 이용, 채팅과 1:1 문의로 연결.
 - API : 채널톡 연동하여 관리자와 직접 실시간 채팅 문의 기능 구현.

---

#2. 1:1문의 - 기능상 유저, 관리자용 페이지 분리

1. 유저 페이지(cslistuser) - 내 1:1 문의 확인 페이지
    - 스크립트 : 토글 이용
    - 유저 확인 방법 : 시큐리티 이용, 사용자 테이블 구조가 최종 확정되지 않은 상태였기 때문에 USERID 직접 참조 대신 EMAIL 기준으로 USERID를 조회하는 임시 메서드 구현
    ```java
        @Select("SELECT * FROM CSQUESTION WHERE USERID = (SELECT USERID FROM USERS WHERE EMAIL = #{email})")
	    List<CSQuestionDto> selectCSQByEmail(@Param("email") String email);
	
	    @Select("SELECT USERID FROM USERS WHERE EMAIL = #{email}")
	    int selectUserIdByEmail(@Param("email") String email);
    ```

    - 답변 매칭 방법 : 각 테이블별 개별 메서드 작성 이후 질문 조회 서비스단에서 for문 이용하여 매칭 

2. 관리자 페이지(cslistadmin) - 전체 1:1 문의 관리 페이지
    1) 답변 완료 전환
        - 0과 1로 답변 상태 설정한 뒤 매퍼에서 update 구문에 case 이용하여 사용(0->1 / 1->0)
        - 관리자 페이지에서 답변 완료 버튼 클릭 이벤트로 전환 가능.
        - 또는 답변 작성 시 자동으로 변동.  

    2) 페이징 
        - Oracle ROW_NUMBER() 기반, 공용 UtilPaging 사용하여 게시글 10개 기준으로 설정. 
        - 스크립트에서 currentMode 변수를 이용, 디폴트 페이징과 검색 전용 페이징으로 구분하여 사용.
    
    3) 서치 : 매퍼 where절에서 choose when 사용. searchType 변수 설정하여 제목, 내용, 닉네임 검색 가능.
    ```java
    	    <where>
			<choose>
			    <when test="searchType == 'title'">
			        lower(q.title) like #{search}
			    </when>
			</choose>
	    </where>
    ```

    4) 정렬 : 매퍼  row_number() over() 내 변수 condition으로 choose when 사용하여 미답변 확인 가능, 스크립트로 버튼 이벤트로 구현.
    ```java
        select row_number() over(
                        <choose>
                            <when test="condition == 'noanswer'">
                                ORDER BY Q.STATUS ASC, Q.QUESTIONID DESC
                            </when>
                        </choose>			)  as rnum, 
    ```
3. 관리자 답변 작성 페이지(cswriteanswer)
    - 게시판 특성상 수정/삭제 불가, 등록 전 onclick="return confirm('답변을 등록하면 수정할 수 없습니다.\n등록하시겠습니까?');" 으로 재확인.

---

#3. 사료 검색 (단일 페이지)

1. 검색 기능
    1) 매퍼
        - 단일 검색이 아닌 다중 필터 형식 이용, where절에 if 구문 사용하고 영양 라벨처럼 다수의 결과가 나오는 컬럼의 경우 EXISTS 이용하여 존재 여부만 확인.
        - 칼로리의 경우 범위 제한이 필요하기 때문에 minvalue, maxvalue 생성하여 범위 구현.
        - 직접 검색은 사용자 피로도를 고려하여 사료명, 재료명 통합으로 제한.
    
    2) 컨트롤러
        - 검색 필터가 선택적으로 적용되는 구조이므로 모든 파라미터를 @RequestParam(required = false)로 처리
        - 수집된 값은 HashMap으로 묶어 서비스/매퍼 단에 전달하여 동적 쿼리 조건으로 활용
    
    3) 검색창 
        - 기초 검색(펫타입, 사료타입, 브랜드, 제품명, 직접검색)과 상세 검색으로 구분.
        - 상세 검색은 토글 이벤트를 버튼에 이용. 
        - 사료명 목록 전체 출력 피로도 방지하기 위해 펫타입과 브랜드를 설정하면 해당하는 조건에 맞는 사료명만 필터창에 출력되게 스크립트 구현
        - 라벨 역시 마찬가지로 펫타입 설정하면 해당하는 라벨명만 출력되도록 스크립트 구현
        - 전체 출력 방지하기 위해 필터 1개 이상 선택 필수 설정

2. 검색 결과 
    1) 결과 출력 
        - 사료명, 브랜드명, 별점, 사료 설명, 이미지의 최소 정보 출력
        - 별점은 리뷰 테이블 데이터 취합, ROUND 함수 이용하여 소수점 1자리까지 나타냄, 스크립트에서 Math.round와 toFixed 이용하여 출력.
        - 버튼 이벤트로 상세 정보와 리뷰 확인 가능

    2) 상세정보(모달)
        - 매퍼 : 중복 행 반환 방지하기 위해 영양 정보의 경우 LISTAGG로 한 줄로 정렬.
        - HTML 영역에 기초 뼈대 설정 후 스크립트 클릭 이벤트로 출력

    3) 리뷰 페이지 연결
        - 리뷰 매퍼와 컨트롤러에 FOODID 조회 전용 메서드 제작하여 버튼 클릭 시 팝업창으로 연결. 

3. API (chatGPT)  
    1) 서비스 - 프롬프트 
        * 필요 데이터 제공 방법
            - 전체 데이터 입력 시 필터 선택에 혼선이 있고 데이터 읽는 시간과 비용 문제로 각 필터들에 어떤 정보가 들어 있는지 제공.
            - 스칼라 서브쿼리에 LISTEGG 사용, 필터 선택지 출력 정보 제공.( EX/ PETTYPENAME -> {고양이, 강아지})
            ```java
            SELECT
                (SELECT LISTAGG(PETTYPENAME, ', ') WITHIN GROUP (ORDER BY PETTYPENAME)
                FROM (SELECT DISTINCT P.PETTYPENAME
                    FROM FOOD F JOIN PETTYPE P ON (P.PETTYPEID = F.PETTYPEID) )
                ) AS PETTYPENAME 		
            FROM DUAL
            ```

        * 명령어 입력
            - StringBuilder 이용, 자연어로 조건 설정하고 for문 이용하여 정보 자연어 형식으로 제공.
        
        * 1차 파싱 – OpenAI 응답 구조 처리
            - 단일 응답 구조기 때문에 배열에서 첫 번째 응답만 가져오도록 처리.   
            - 메시지가 출력되지 않을 경우를 대비하여 defaultResult 기본 메시지 설정

        * 2차 파싱 – AI가 생성한 JSON 문자열 해석
            - filtersNode와 messageNode로 분리
            - filtersNode와 : 내부 데이터, 필터 설정용
            - messageNode로 : 사용자에게 출력될 메시지

    3) VIEW   
        - 토글 버튼으로 입력창 열기, 사용자가 자연어 입력 시 AI가 간단한 설명과 함께 필터 변경 자동 적용.
        - 펫타입의 경우 AI는 string, 검색필터는 int로 받기 때문에 스크립트에서 int->string->int 변환.

---

#4. 사료 관리자 게시판 API(NAVER OCR)

 1) 서비스  
    - MultiValueMap 이용, 외부 NAVER OCR API에 이미지 파일을 multipart/form-data 형식으로 전송하여 텍스트 인식.
    - OCR 응답 JSON을 Jackson의 JsonNode 트리 모델로 파싱하여 결과 문자열인 inferText 필드만 추출.

 2) 컨트롤러 : db에 저장하지 않는 임시 데이터이므로 컨트롤러에서는 단순 변환 수행 후 임시파일 삭제. 

 3) view 
    - 사료 라벨 특성상 업체별, 제품별 순서와 규격이 다른 비정형 데이터이므로 신뢰도 및 좌표 기반 자동 분류에 한계가 있어 관리자가 직접 확인, 보정할 수 있도록 별도의 추출 영역으로 구성.
    - 아작스에서 data 타입은 formData로 첫 번째 배열값 받아옴.
    - processData: false, contentType: false 설정하여 받아온 파일의 문자열 반환 금지, multipart 형식 유지.

---

#5. 리뷰 게시판API(chatGPT)

 1) 서비스 
    - OpenAI 응답 JSON 중 choices[0].message.content 값만 추출.
    - Jackson의 JsonNode 트리 파싱 방식 이용.
 
 2) view
    - API를 활용해 사용자가 작성한 리뷰의 표현을 중립적으로 정제하는 보조 기능 구현.
    - 바로 텍스트를 대체하지 않고 따로 파싱 결과물을 출력 후 사용자가 비교 후 대체 여부 선택 가능.
    