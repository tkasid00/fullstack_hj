# ■ Java

1. 다형성
- 많은 형상을 띠는 성품
- 여러 타입의 객체(자식)를 하나의 타입(부모)으로 관리

2. 부모는 자식을 담을 수 있다(업캐스팅)
 ------------------------------------
 Animal{name, age/먹기, 자기, 배변}
   ↑
 Cat{card/꾹꾹이}
 ------------------------------------
Animal ani = new Cat();   부모 = 자식 (고양이는 동물이다)

2-1) Animal ani{name, age/먹기, 자기, 배변}
2-2) new cat : Cat()->Animal()->Object() 호출
        {card/꾹꾹이} + {name, age/먹기, 자기, 배변}


3. 자식은 부모를 담을 수 있다(다운캐스팅)
 Cat cat = new Animal(); 자식 = 부모

3-1) Cat cat; {card/꾹꾹이} + {name, age/먹기, 자기, 배변}
3-2) new Animal() {name, age/먹기, 자기, 배변}
3-3) 만족시키지 못하는 범위 발생 {card/꾹꾹이}
★3-4) 해결 방안 : 부모 타입에서 자식 생성자를 호출한 적이 있으면 사용 가능.
Animal ani = new Cat(); 3000번지 {card/꾹꾹이} + [ {name, age/먹기, 자기, 배변} ]
 -> 자식 생성자 호출로 자식의 범위 초기화(사용 가능) 
 -> Cat cat = (Cat)ani [ {card/꾹꾹이} + {name, age/먹기, 자기, 배변} ]


--- 

 ● 9. abstract
 1. 추상화
 - 실체화된 객체들 간 공통 특성 추출
 - 미완성적인 개념(new 사용 불가)
 - 공통된 필드와 메서드의 이름을 통일할 목적

 2. 추상 클래스
 -------------------------------------------
 abstrack class Animal{
    String name; //인스턴스 변수 - this - 각각
    abstrack void sound(); //abstract method() - {} 구현부 x
 }
 
 class Cat estends Animal{ @override void sound(){야옹} }
 class Dog estends Animal{ @override void sound(){멍멍} }
 -------------------------------------------

 ● 10. interface
  1. interface
  - 개발 코드 변경 없이 객체를 바꿔 끼울 수 있도록 하는 역할

  2. abstract(Is A : 고양이는 동물이다) vs interface(can do this)
  - 추상화 정도가 interface가 더 높음
  1) abstract - 인스턴스 변수, 일반 메서드, 추상 메서드(abstract) 가질 수 있음
  2) interface - 상수(public static final) + 추상 메서드(public abstract) 만 가질 수 있음

  3. 프로젝트 진행 시 interface 사용
  다른 구성원들이 각각의 부분을 완성할 때까지 기다리지 않고 규약만 정해두고 본인 부분만 작성

  4. interface 형식 (설계 클래스)
 -------------------------------------------
  interface 인터페이스명{
   상태 : 상수; -> public static final
    행위 :추상 메서드; -> public abstract  {} x - this x 
  }
 -------------------------------------------
 class interSon implements 인터페이스명{}
 class interSon2 extends 클래스명 implements 인터페이스1, 인터페이스2{}
  ->물리적 확장 불가




 ● 기타 개인 공부
 1. Math.random() 메서드
 - 기본적으로 0.0~1.0 사이 double값 
    double r = Math.random();
    System.out.println(r);  // 0.0 <= r < 1.0

 - 정수로 바꾸기(0~9)
    int n = 10;
    int r = (int)(Math.random() * n);
    System.out.println(r);  // 0~9

 - 5~15 설정
    int min = 5, max = 15;
    int r = (int)(Math.random() * (max - min + 1)) + min;
                                    (15 - 5 + 1)   + 5
    System.out.println(r);  // 5~15
 
 - 주사위 굴리기 
    int dice = (int)(Math.random() * 6) + 1;
	 (int)(0.0 <= r < 1.0 * 6) +1;	
	 (int)(0.0 <=r<6.0) +1	
    System.out.println("주사위: " + dice); // 1~6

 - 확률 이벤트    
    if (Math.random() < 0.3) {
        System.out.println("당첨!");
    } else {
        System.out.println("꽝...");
    }


 2. random 클래스    
 - 객체 생성 필요 import java.util.Random;
            Random rand = new Random();
 - 다양한 형태 : nextInt(), nextDouble(), nextBoolean()           
 - 예) int r = rand.nextInt(10); // 0~9          

 3. Math.max()
 - Math.max(a, b) 중 큰 값 반환
 - 중첩 사용 가능(삼항연산자랑 비슷)
    int x = 10, y = 25, z = 7;
    int max = Math.max(x, Math.max(y, z)); 
    System.out.println(max); // 25

 - 배열의 경우
    int[] arr = {3, 8, 1, 6, 10};
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        max = Math.max(max, arr[i]);
    }
    System.out.println("최대값: " + max); // 10   

    ->int max = arr[0]; 는 배열 안의 유효한 값으로 초기화해서 비교함.


 # ■ WebBasic

010. JQUERY

1. 기본 형태  : $(document).ready(function(){      }); //end ready

2. 축약 :  $(function(){        });
    1) 일반 태그 : $("p").css({"color" :  "blue", "fontSize" : "15px"});
    2) 아이디 : $("#hello").css({"backgroundColor":"black", "color":"white"});
    3) 클래스 : $(".greeting").css({ "fontSize":"20px", "textAlign":"center", "textDecoration":"underline"});
    4) 자식 태그 : $("ul>li").css({"color":"gold"});
    5) 첫 번째 : $("div:first").css({"border":"10px dashed black "});
    6) 선택 이전 : $(".item").prev().css({"textAlign":"center"});
    7) 선택 다음 : $(".item").next().css({"textAlign":"right"});
    8) 이벤트 2개 연결 :  $(".card").on( "click", function(){}   ).on(  "click", function(){}  );
