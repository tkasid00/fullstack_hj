--1. JOIN
-- 여러 테이블을 한 개의 테이블처럼 사용하는 것 
-- 공통 컬럼 기준으로 연결
-- *내부 조인
--   등가 조인(=) : 매칭되는 행(WHERE절 EMP.DEPTNO=DEPT.DEPTNO)
--   비등가 조인(= X): SAL BETWEEN LOSAL AND HISAL
--   자체 조인 : EMP E1, EMP E2
-- *OUTER JOIN : 매칭되지 않은 행도 포함 (LEFT, RIGHT, FULL OUTER JOIN)
-- 

-- ERD : ENTITY(테이블), RELATIONSHIP(관계), DIAGRAM(표)
-- ENTITY(테이블), RELATIONSHIP(관계), ATTRIBUTE(속성)

--#1.내부 조인(등가 조인)
SELECT * 
FROM EMP, DEPT
WHERE EMP.DEPTNO=DEPT.DEPTNO;

SELECT * 
FROM EMP, DEPT;  --14*4=56줄

SELECT * 
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO;

SELECT * 
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO);

SELECT * 
FROM EMP E JOIN DEPT D USING(DEPTNO);  --DEPTNO 하나로 합쳐서 출력

SELECT *
FROM EMP E NATURAL JOIN DEPT D;


-- EMP E, DEPT D 별병 / EMPNO, ENAME, DEPTNO, DNAME 구하기
SELECT EMPNO, ENAME, DEPTNO, DNAME  -- DEPTNO 소속 불분명으로 출력 불가
FROM EMP E , DEPT D;

SELECT EMPNO, ENAME, E.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO;

SELECT EMPNO, ENAME, E.DEPTNO, DNAME
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO); --ON : 필드가 달라도 자료형 맞으면 출력

SELECT EMPNO, ENAME, DEPTNO, DNAME
FROM EMP E JOIN DEPT D USING(DEPTNO);   --USING은 DEPTNO 필드가 1개로 출력되기 때문에 E.DEPTNO 불가

SELECT EMPNO, ENAME, DEPTNO, DNAME
FROM EMP E NATURAL JOIN DEPT D;

-- -----------------------------------------------------------------------------

--#2. 외부 조인(매칭X)
SELECT * FROM DEPT;   -- DEPTNO 10,20,30,40(OPERATIONS, BOSTON)
SELECT * FROM EMP;  -- DEPTNO 10,20,30

-- 1. 조건(+)(ORACLE 전용) : 없는 데이터 보충해서 NULL값 채워줌
--                          (+) 붙은 테이블에 NULL값 채워서 (+) 붙지 않은 테이블의 데이터 보장
SELECT ENAME, DNAME 
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO(+); --14줄 :  EMP 보장

SELECT ENAME, DNAME 
FROM EMP E, DEPT D
WHERE E.DEPTNO(+)=D.DEPTNO; --15줄 : DEPT 보장(EMP에 NULL 채움)

-- 2. LEFT JOIN, RIGHT JOIN(ANSI 조인=표준)
 
--내부 조인(겹치는 경우)
SELECT ENAME, DNAME 
FROM EMP E INNER JOIN  DEPT D  ON (E.DEPTNO=D.DEPTNO);

--RIGHT 쪽 테이블 보장(DEPT 값 전부 출력)
SELECT ENAME, DNAME 
FROM EMP E RIGHT OUTER JOIN DEPT D 
ON (E.DEPTNO=D.DEPTNO);

----LEFT 쪽 테이블 보장(EMP 값 전부 출력)
SELECT ENAME, DNAME 
FROM EMP E LEFT OUTER JOIN DEPT D 
ON (E.DEPTNO=D.DEPTNO);


-- 3. OUTER JOIN (두 테이블의 모든 데이터 결합)
SELECT E.ENAME, D.DNAME 
FROM EMP E FULL OUTER JOIN DEPT D 
ON E.DEPTNO=D.DEPTNO;

-- 비표준 :  =, (+)
-- 표준 : NAUTRAL JOIN, JOIN ON, JOIN USING, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN
--   ㄴINNER, OUTER 생략 가능



-- https://sally03915.github.io/stackventure_250825/004_oracle/oracle006_select_join#14
-- Q1~8

--1. EMP, DEPT 테이블을 이용하여 FROM 절에 여러 테이블을 선언해해 다음과 같이 출력하시오
-- 모든 행과 열이 곱해진 값
SELECT *
FROM EMP, DEPT
ORDER BY EMPNO;

--2.EMP, DEPT 테이블을 이용하여 EMP의 DEPTNO와 DEPT테이블의 DEPTNO가 같은 데이터를 다음과 같이 출력하시오
SELECT *
FROM EMP JOIN DEPT ON(EMP.DEPTNO=DEPT.DEPTNO)
ORDER BY EMPNO;

--3. EMP, DEPT 테이블을 이용하여 FROM 절에 EMP 테이블의 별칭은 E, DEPT 테이블의 별칭은 D로 다음과 같이 출력하시오
SELECT *
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
ORDER BY EMPNO;

--4.EMP, DEPT 테이블을 이용하여 두테이블에 부서번호가 같은 열의이름이 포함되었을때 다음과 같이 출력하시오 (에러발생)
SELECT EMPNO, ENAME, DEPTNO, DNAME, LOC
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
ORDER BY EMPNO;

--5.EMP, DEPT 테이블을 이용하여 열 이름에 각각의 테이블 이름도 함께 명시해 다음과 같이 출력하시오 ( 위의 문제 해결 )
SELECT EMPNO, ENAME, E.DEPTNO, DNAME, LOC
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
ORDER BY DEPTNO;

--6. EMP, DEPT 테이블을 이용하여 급여가 3000이상인 사원의 사원번호, 이름, 급여, 근무부서를 다음과 같이 출력하시오
--USING
SELECT EMPNO, ENAME, SAL, DEPTNO, DNAME, LOC
FROM EMP E JOIN DEPT D USING(DEPTNO)
WHERE SAL>=3000
ORDER BY SAL DESC;

--ON
SELECT EMPNO, ENAME, SAL, E.DEPTNO, DNAME, LOC
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
WHERE SAL>=3000
ORDER BY SAL DESC;

-- =
SELECT EMPNO, ENAME, SAL, E.DEPTNO, DNAME, LOC
FROM EMP E, DEPT D
WHERE SAL>=3000 AND E.DEPTNO=D.DEPTNO
ORDER BY SAL DESC;

--NATURAL
SELECT EMPNO, ENAME, SAL, DEPTNO, DNAME, LOC
FROM EMP E NATURAL JOIN DEPT D
WHERE SAL>=3000
ORDER BY SAL DESC;


--7. EMP, SALGRADE 테이블을 이용하여 유저 정보, 급여등급 , 그 등급의 최소급여와 최대급여를 다음과 같이 출력하시오
--USING은 겹치는 필드 없어서 사용X
--서브쿼리 이용해서 이렇게 해야됨
SELECT *
FROM EMP JOIN (   
    ( SELECT SAL
    , CASE 
        WHEN SAL BETWEEN 700 AND 1200 THEN 1
        WHEN SAL BETWEEN 1201 AND 1400 THEN 2
        WHEN SAL BETWEEN 1401 AND 2000 THEN 3
        WHEN SAL BETWEEN 2001 AND 3000 THEN 4
        WHEN SAL BETWEEN 3001 AND 9999 THEN 5
        END AS GRADE FROM EMP ) CALGRADE    JOIN SALGRADE USING(GRADE)  )  USING(SAL)
    ORDER BY HISAL;

-- ==
SELECT * 
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- NATURAL
SELECT * 
FROM EMP E NATURAL JOIN SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

SELECT * 
FROM EMP E JOIN SALGRADE S ON(E.SAL BETWEEN S.LOSAL AND S.HISAL);



--8.EMP테이블을 2번 이용하여 사원정보(EMPNO, ENAME, MGR) 와 직속상관((EMPNO, ENAME, MGR)의 사원번호를 다음과 같이 출력하시오
-- ON
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 JOIN EMP E2 ON (E1.MGR=E2.EMPNO)
WHERE E1.MGR IS NOT NULL
ORDER BY E2.EMPNO;

-- =
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 , EMP E2 
WHERE E1.MGR IS NOT NULL AND E1.MGR = E2.EMPNO;

--USING, NATURAL 사용X


-- https://sally03915.github.io/stackventure_250825/004_oracle/oracle006_select_join#33
-- Q9~16

--9. EMP테이블을 2번 이용하여 사원정보(EMPNO, ENAME, MGR) 와 직속상관(EMPNO, ENAME)의 사원번호를 다음과 같이 출력하시오 
-- 직속상관이 없는 사원의 정보도 출력하시오

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT JOIN EMP E2 ON (E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO;

--10. (+)의 위치를 바꿔서 출력해보고 다음이 의미하는 바를 적으시오
--(+)가 붙은 테이블에 NULL값 채워서 (+)가 붙지 않은 쪽의 데이터 출력 보장

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 , EMP E2 
WHERE E1.MGR(+) = E2.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 , EMP E2 
WHERE E1.MGR = E2.EMPNO(+);

--11. EMP , DEPT 테이블 이용하여 EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM를 다음과 같이 출력하시오
-- NATURAL JOIN

SELECT  EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME, LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, EMPNO;

-- 12. JOIN USING
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME, LOC
FROM EMP E JOIN DEPT D USING(DEPTNO)
WHERE SAL>=3000;

-- 13. JOIN ON
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
ORDER BY DEPTNO, EMPNO;

-- 14.LEFT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT JOIN EMP E2 ON(E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO, MGR_EMPNO;

--15. RIGHT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT JOIN EMP E2 ON(E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO, MGR_EMPNO;

--16. FULL OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 FULL OUTER JOIN EMP E2 ON(E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO, MGR_EMPNO;

--EX001. EMP, DEPT 테이블을 이용하여 SQL-99 이전 방식다음 , SQL-99방식 두가지 방식으로 다음과 같이 출력하시오.
-- 급여(SAL)이 2000초과인 사원들의 부서정보, 사원정보를 출력하시오.

SELECT E.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E, DEPT D
WHERE SAL>2000 AND E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO; 

SELECT DEPTNO, DNAME, EMPNO, ENAME, SAL
FROM EMP JOIN DEPT USING(DEPTNO)  
WHERE SAL>2000
ORDER BY DEPTNO;

SELECT E.DEPTNO, DNAME, EMPNO, ENAME, SAL
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)  
WHERE SAL>2000
ORDER BY DEPTNO;

SELECT DEPTNO, DNAME, EMPNO, ENAME, SAL
FROM EMP NATURAL JOIN DEPT  
WHERE SAL>2000
ORDER BY DEPTNO;


--EX002 EMP, DEPT 테이블을 이용하여 SQL-99 이전 방식다음 , SQL-99방식 두가지 방식으로 다음과 같이 출력하시오.
-- 각 부서별 평균급여, 최대급여, 사원수를 출력하시오.
SELECT E.DEPTNO, D.DNAME, TRUNC(AVG(E.SAL) ) AS AVG_SAL, MAX(E.SAL) AS MAX_SAL, MIN(E.SAL) AS MIN_SAL, COUNT(E.EMPNO) AS CNT
FROM EMP E, DEPT D
WHERE  E.DEPTNO = D.DEPTNO
GROUP BY E.DEPTNO, D.DNAME
ORDER BY DEPTNO;

SELECT DEPTNO, DNAME, TRUNC(AVG(SAL)) AS AVG_SAL, MAX(SAL) AS MAX_SAL, MIN(SAL) AS MIN_SAL, COUNT(EMPNO) AS CNT
FROM EMP E JOIN DEPT D USING(DEPTNO)
GROUP BY DEPTNO, DNAME;

SELECT DEPTNO, DNAME, TRUNC(AVG(SAL)) AS AVG_SAL, MAX(SAL) AS MAX_SAL, MIN(SAL) AS MIN_SAL, COUNT(EMPNO) AS CNT
FROM EMP E NATURAL JOIN DEPT D
GROUP BY DEPTNO, DNAME;

SELECT E.DEPTNO, D.DNAME, TRUNC(AVG(SAL)) AS AVG_SAL, MAX(SAL) AS MAX_SAL, MIN(SAL) AS MIN_SAL, COUNT(EMPNO) AS CNT
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
GROUP BY E.DEPTNO, DNAME;


--EX003. 모든 부서정보와 사원정보를 부서번호, 사원이름 순으로 정렬해 출력하시오.
SELECT D.DEPTNO, D.DNAME, EMPNO, ENAME, JOB, SAL
FROM EMP E, DEPT D
WHERE  E.DEPTNO(+) = D.DEPTNO
ORDER BY DEPTNO, DNAME, ENAME; 

SELECT DEPTNO, DNAME, EMPNO, ENAME, JOB, SAL
FROM EMP RIGHT OUTER JOIN DEPT USING(DEPTNO)
ORDER BY DEPTNO, DNAME, ENAME; 

SELECT DEPTNO, DNAME, EMPNO, ENAME, JOB, SAL
FROM DEPT LEFT OUTER JOIN EMP USING(DEPTNO)
ORDER BY DEPTNO, DNAME, ENAME; 



--EX004. 모든 부서정보와 사원정보, 급여등급정보, 각사원의 직속상관의 정보를 부서번호, 사원번호 순서로 정렬해 출력하시오.
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO, S.LOSAL, S.HISAL, S.GRADE, MGR_EMPNO, MGR_ENAME
FROM EMP E, DEPT D, SALGRADE S
,(SELECT EMPNO AS MGR_EMPNO, ENAME AS MGR_ENAME FROM EMP) MGTAB
WHERE E.MGR = MGTAB.MGR_EMPNO(+)
AND  E.DEPTNO(+) = D.DEPTNO
AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)    --여기도 (+) 넣어줘야됨! 
ORDER BY D.DEPTNO, E.ENAME;
---▽▽▽▽
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO, S.LOSAL, S.HISAL, S.GRADE, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E, DEPT D, SALGRADE S, EMP E2
WHERE E.MGR = E2.EMPNO(+)
AND  E.DEPTNO(+) = D.DEPTNO
AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)   
ORDER BY D.DEPTNO, E.ENAME;


SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO, S.LOSAL, S.HISAL, S.GRADE, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E 
    FULL OUTER JOIN EMP E2 ON(E.MGR=E2.EMPNO) 
    JOIN SALGRADE S ON(E.SAL BETWEEN S.LOSAL AND S.HISAL) 
    FULL OUTER JOIN DEPT D ON(E.DEPTNO=D.DEPTNO)
ORDER BY D.DEPTNO, E.ENAME;

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO, S.LOSAL, S.HISAL, S.GRADE, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E RIGHT JOIN DEPT D ON (E.DEPTNO=D.DEPTNO) LEFT JOIN SALGRADE S ON(E.SAL BETWEEN S.LOSAL AND S.HISAL) LEFT JOIN EMP E2 ON (E.MGR=E2.EMPNO) 
ORDER BY D.DEPTNO, E.ENAME;






--복습
--(0) 비표준
SELECT EMPNO, ENAME, D.DEPTNO, DNAME   --겹치는 경우만 E, D 달면 됨
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO;

--(1) JOIN ON  SQL-99 표준
SELECT EMPNO, ENAME, D.DEPTNO, DNAME  
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D.DEPTNO) ;

--(2) JOIN USING SQL-99 표준
SELECT EMPNO, ENAME, DEPTNO, DNAME  
FROM EMP E JOIN DEPT D USING(DEPTNO) ;

--(3) NATURAL JOIN  SQL-99 표준
SELECT EMPNO, ENAME, DEPTNO, DNAME  
FROM EMP E NATURAL JOIN DEPT D ;

--(4)
SELECT * FROM DEPT; --부서 : 10,20,30,40

SELECT EMPNO, ENAME, D.DEPTNO, DNAME   --겹치는 경우만 E, D 달면 됨
FROM EMP E, DEPT D 
WHERE E.DEPTNO(+)=D.DEPTNO;

--(5) RIGNT OUTER JOIN
SELECT EMPNO, ENAME, D.DEPTNO, DNAME  
FROM EMP E RIGHT OUTER JOIN DEPT D ON(E.DEPTNO=D.DEPTNO) ;

--(6) LEFT OUTER JOIN
SELECT EMPNO, ENAME, D.DEPTNO, DNAME  
FROM DEPT D LEFT OUTER JOIN EMP E ON(E.DEPTNO=D.DEPTNO) ;

--(7) FULL OUTER JOIN
SELECT EMPNO, ENAME, D.DEPTNO, DNAME  
FROM EMP E FULL OUTER JOIN DEPT D  ON(E.DEPTNO=D.DEPTNO) ;