## Part001.linux

## Ubuntu 24.04 컨테이너 실행 방법
1. **이미지 다운로드**
   ```bash
   docker pull ubuntu:24.04
   ```

2. **컨테이너 실행**
   ```bash 
   docker run -it --name myubuntu ubuntu:24.04 bash
   ```
   → 실행하면 컨테이너 내부의 쉘(`bash`) 
   - -it : i(표준 입력) , t(터미널/가상터널) 
   - --name myubuntu 컨테이너 이름
   - ubuntu:24.04 버전
   - bash 내부 쉘 띄우기

3. **컨테이너 내부에서 패키지 업데이트**
   ```bash
   apt update && apt upgrade -y
   ```cd f

4. **컨테이너 종료 후 다시 실행하기**
   - 실행 중인 컨테이너 확인:
     ```bash
     docker ps -a
     ```
   - 컨테이너 재실행:
     ```bash
     docker start -ai <컨테이너_ID>
     docker start -ai myubuntu 
     ```
    - 실행 중인 컨테이너에 접속:
     ```bash
    docker exec -it myubuntu bash
    ```
 ## 2. linux 사용자
 1. '#' root 사용자
 2. '$' 일반 사용자

## 3. 기본 명령어
```bash
#날짜
date 
#출력구문
echo hello 
#명령어 위치 확인
witch date 
#명령어 설명서 
man date
```

- 필요할 경우
```bash
apt update
apt install man-db  
unminimize  #버전 복원
```

```bash
help echo -> 쉘 내장 명령어
man date  -> 독립된 실행 파일
q -> 빠져나오기
type echo -> echo is a shell builtin
type date -> date is hashed (/usr/bin/date)
```

```bash
↑↓ 명령어 확인    # '+' 포멧 형식
date  "+%Y-%m-%d" -> 2026-02-03   
date  "+Y-%m-%d" -> Y-02-03   
```
Q1. hi 출력
Q2. date 사용 방법 확인 


## 4. 파일
 
### 파일 및 디렉토리 생성
- touch 파일명 : 빈 파일 생성
- mkdir 디렉토리명 : 새 디렉토리 생성
- mkdir -p 경로/하위디렉토리 : 중첩 디렉토리 생성

### 파일 확인 및 경로 이동
- ls : 현재 디렉토리 목록 보기
- ls -l : 상세 정보 포함 목록
- pwd : 현재 경로 출력
- cd 디렉토리명 : 디렉토리 이동
- cd .. : 상위 디렉토리로 이동

### 삭제 및 복사
- rm 파일명 : 파일 삭제 (확장자 필요 rm hello.txt)
- rm -r 디렉토리명 : 디렉토리 삭제
- cp 원본 대상 : 파일 복사 (cp file1.txt backup.txt)
- mv 원본 대상 : 파일 이동 또는 이름 변경(mv backup.txt final.txt)

Q1. testdir 폴더 만들기Q2. 
Q2. 폴더 안에 file1.txt 파일 만들기
Q3. 파일 확인 - 디렉토리, 파일인지 구분

### 파일에 적기 (1) 덮어쓰기 > / 이어쓰기 >>
- 덮어쓰기 : echo "하고싶은말" > file1.txt
- 한 줄씩 이어쓰기 : echo "하고싶은말" >> file1.txt
- cat file1.txt  
```bash 
echo "first" > file1.txt
cat file1.txt  # first
echo "second" > file1.txt 
cat file1.txt  # second
echo "first" >> file1.txt
cat file1.txt  # second/first
```

Q1. file1.txt에 입력
apple
banana
coconut 

### 파일에 적기 (2) 여러 줄 쓰기
### 여러줄
cat > file2.txt 
첫 번째 줄 
두 번째 줄 
Ctrl+D # 입력 종료

### 파일에 적기 (3) 파일 편집
### vi 에디터
1. sudo vi 파일명 실행 (sudo file1.txt)  
2. vi 안에서 Esc 눌러 명령 모드로 전환   
3. i 눌러 입력 모드로 전환 → 새 설정 붙여넣기  
4. Esc → :wq → 저장 후 종료   

```bash
# 설치
apt update
apt install vim
y
5(Asia) -> 68(Soul)
```
Q1. file2.txt vi 에디터 이용 편집
one-1
two-2
three-3


Q1. 파일만들기   mylinux.txt
Q2. 파일안에 답채우기
-    출력
-    사용서
-    파일생성
-    디렉토리만들기
-    목록보기
-    상위이동
-    파일,폴더삭제
-    file1.txt 을 back.txt으로 파일복사
-    back.txt를 test.txt로 이름변경
Q3. vi이용해서 맨위에 작성자본인이름 추가
Q5. mylinux.txt 백업해서 ubuntu에 backup.txt로 
Q6. 상위로 이동 testdir 삭제

```bash
이름 변경 : mv file1.txt back.txt
파일 이동: mv backup.txt /home/ubuntu/
파일 이동+변경 : mv backup.txt /home/ubuntu/final.txt
```

```bash
#한글출력
apt update
apt install locales
locale-gen ko_KR.UTF-8
update-locale LANG=ko_KR.UTF-8
```

## 5. 유저
# 사용자 정보 확인
whoami
id
who
users
groups

# 사용자 추가 및 삭제
sudo adduser sally
sudo passwd sally
sudo deluser sally

# 권한 구조 및 변경
ls -l
sudo chown sally:sally hello.txt
chmod 755 hello.txt
umask

```bash
apt update
apt install adduser
adduser butter
```

```
drwxr-x--- 2 butter butter 4096 Feb  3 15:04 .
drwxr-xr-x 1 root   root   4096 Feb  3 14:57 ..
-rw------- 1 butter butter   45 Feb  3 15:04 .bash_history
-rw-r--r-- 1 butter butter  220 Feb  3 14:57 .bash_logout
-rw-r--r-- 1 butter butter 3771 Feb  3 14:57 .bashrc
-rw-r--r-- 1 butter butter  807 Feb  3 14:57 .profile

-rwx : 파일(-)/디렉토리(r) 서유자 소유자그룹 기타
- r(읽기 4) / w(쓰기 2) / x(실행 1)
```

Q1. alpha 유저 만들기 비번 1234
Q2. alhpa로 로그인 / alpha 홈 디렉토리 찾아가기
Q3. alhpa로 로그인 / butter 홈 디렉토리 찾아가기 -> 불가

```
chmod 755 /home/butter
ls -l
```


## 6. job + 쉘스크립트
1. 프로세스 상태 확인 
```
ps -ef
```
1) -e 모든 프로세스
2) -f 출력 정보 자세히

2. 실시간 모니터링
```
top
```
3. ip주소 확인
```
ifconfig 
ip add show
```
4. Hello world 쉘스크립트 작성
```
vi hello.sh

#!/bin/bash
echo "hello world"
```

```
ls -al   #권한
chmod 755 +x hello.xh
```
5. 쉘스크립트 실행
```
./hello.sh
```


## Part002.aws
1. 회원가입
https://aws.amazon.com/ko/

**실행 항목**
- [ ] EC2 인스턴스 생성  
- [ ] OS 선택 (Ubuntu 권장)  
- [ ] 보안 그룹 설정 (22, 80, 443)  
- [ ] 키페어 다운로드 및 저장  
- [ ] SSH 접속 테스트 완료  

1. 퍼블릭 ip
54.206.106.20

2. SSH 클라이언트(접속 명령어)
ssh -i "thejoa703.pem" ubuntu@ec2-13-236-66-10.ap-southeast-2.compute.amazonaws.com

```bash
#권한 문제 해결
icacls "D:\Hyunju\workspace\fullstack_hj\track009_Linux+gitAction+cicd+aws\cicd\thejoa703.pem" /reset
icacls "D:\Hyunju\workspace\fullstack_hj\track009_Linux+gitAction+cicd+aws\cicd\thejoa703.pem" /inheritance:r
icacls "D:\Hyunju\workspace\fullstack_hj\track009_Linux+gitAction+cicd+aws\cicd\thejoa703.pem" /grant:r "%username%:R"   #whoami로 찾기
```

■ 4. EC2에서 nginx
- 웹서버 연결 
- back+front 연결 설정 

1. nginx 설치
```
apt update
apt update install nginx -y
```
2. nginx 설정 파일 수정
```
vi /etc/nginx/sites-available/default
```

2-1.
```
sudo vi /etc/nginx/sites-available/default 
```

2-2. esc 눌러서 명령모드 전환
2-3. :$d 입력 뒤 enter ->전체 삭제
2-4. i 눌러서 입력모드 전환 ->붙여넣기
2-5. esc -> :wq!


```bash
server{
   listen 80;
   server_name 54.206.106.20
   
   #프론트엔드(Next.js SSR서버)
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header Cookie $http_cookie; 
    }

   #백엔드(순서 조심!) - 유저 인증(/auth)
       location /auth {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host; 
        proxy_set_header X-Real-IP $remote_addr;   # 프론트 ip 받아오기
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    #접속목록
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Cookie $http_cookie; 
    }

   #백엔드 - 일반 api(/api)
       location /api {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host; 
        proxy_set_header X-Real-IP $remote_addr;  
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Cookie $http_cookie; 
    }

     #백엔드 - 소셜로그인(/oauth2)
       location /oauth2 {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host; 
        proxy_set_header X-Real-IP $remote_addr;  
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Cookie $http_cookie; 
    }  
     #백엔드 - (구글>도메안 필요)/카카오/네이버 리다이렉트 처리
       location /login/oauth2 {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host; 
        proxy_set_header X-Real-IP $remote_addr;   
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;   
        proxy_set_header X-Forwarded-Proto $scheme;
    }  

     #프론트엔드에서 처리해야 하는 콜백
       location /oauth2/callback {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host; 
        proxy_set_header X-Real-IP $remote_addr;   
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Cookie $http_cookie; 
    }  

      #정적파일 경로
       location /uploads/ {
       alias /home/ubuntu/app/back/build/libs/uploads;
       autoindex off;
    }  
}
```

```bash
    location / {    # /이 경로로 
        proxy_pass http://localhost:3000;   #포트번호 3000번
        proxy_http_version 1.1;     # 백엔드와 통신 시 http(사용 언어)
        proxy_set_header Upgrade $http_upgrade;  # 헤더 그대로 전달
        proxy_set_header Connection "upgrade";  # 헤더 강제 설정 
        proxy_set_header Host $host;   # host 백엔드로 전송
        proxy_cache_bypass $http_upgrade; # 연결 시 캐시 사용x 
        proxy_set_header Cookie $http_cookie;   # 쿠키 백엔드 서버로 전달
    }

```


```bash
#완성본
server {
    listen 80;
    server_name 13.236.66.10;

    # 프론트엔드 (Next.js SSR 서버)
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header Cookie $http_cookie;
    }

    # 백엔드 - 유저 인증 (/auth)
    location /auth {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Cookie $http_cookie;
    }

    # 백엔드 - 일반 API (/api)
    location /api {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Cookie $http_cookie;
    }

    # 백엔드 - 소셜 로그인 (/oauth2)
    location /oauth2 {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Cookie $http_cookie;
    }

    # 백엔드 - 카카오/구글 리다이렉트 처리
    location /login/oauth2 {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # 프론트엔드에서 처리해야 하는 콜백
    location /oauth2/callback {
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Cookie $http_cookie;
    }

    # 정적 파일 경로
    location /uploads/ {
        alias /home/ubuntu/app/back/build/libs/uploads/;
        autoindex off;
    }

}
```
3. nginx 실행 및 테스트

```bash
sudo nginx -t     #테스트
sudo systemctl restart nginx   
```

■ 5. ECR 리포지토리
- 애플리케이션을 docker 이미지로 빌드해서 ecr에 올려두면 어디서든지 가져다 사용할 수 있게 

※ AWS콘솔창에서 검색 ECR - 생성

1. **리포지토리 이름 입력 : `thejoa703`**  
   - 예: `my-app-repo`  
   - 규칙:  
     - 소문자로 시작해야 함  
     - 소문자, 숫자, 특수문자(`._-/`)만 사용 가능  
     - 최소 2자, 최대 256자  
   - `734910190986.dkr.ecr.ap-northeast-2.amazonaws.com/` 이건 **리포지토리 URI의 기본 형식**이고, 뒤에 붙는 이름을 직접 정해야 합니다.  
     → 즉, `734910190986.dkr.ecr.ap-northeast-2.amazonaws.com/my-app-repo` 이런 식으로 완성됩니다.  
<br/>

2. **이미지 태그 설정 (Mutable vs Immutable) : `Mutable`**  
   - **Mutable**: 같은 태그(`latest` 등)를 덮어쓸 수 있음 → 개발/연습용에 적합  
   - **Immutable**: 태그를 덮어쓸 수 없음 → 운영 환경에서 안정성 확보용  
   → 연습용이라면 **Mutable**로 두시면 됩니다.  
<br/>

3. **암호화 설정**  
   - 기본값(KMS 관리형 키) 그대로 두셔도 무방합니다.  
<br/>

4. **생성 버튼 클릭**  
   - 그러면 새 리포지토리가 만들어지고, 목록에 `my-app-repo`가 나타납니다.  


>   791263467213.dkr.ecr.ap-southeast-2.amazonaws.com/thejoa703


■ 6. 필수 패키지 설치 / 애플리케이션 디렉토리 생성 

1. EC2접속 후 시스템 업데이트  
   ```bash
   sudo apt update && sudo apt upgrade -y
   ```
2. Java 17 설치  
   ```bash
   sudo apt install openjdk-17-jdk -y
   java -version
   ```
3. Git 설치  
   ```bash
   sudo apt install git -y
   ```
4. Docker 설치  (자동부팅)
   ```bash
   sudo apt install docker.io -y
   sudo systemctl enable docker && sudo systemctl start docker
   sudo usermod -aG docker $USER  #유저 모드 
   ```
5. Node.js & NPM 설치  
   ```bash
   curl -fsSL https://deb.nodesource.com/setup_24.x | sudo -E bash -
   sudo apt install -y nodejs

   ```
6. PM2 설치   - 자동 reload
   ```bash
   sudo npm install -g pm2
   ```
7. Nginx 설치  (위에서 설치 완료 시 생략)
   ```bash
   sudo apt install nginx -y
   ```

   **구조확인**
   ```
   thejoa703/                ← 깃허브 저장소 루트
   ├── .git                  ← Git 저장소 메타데이터
   ├── .gitignore            ← 불필요한 파일 제외 설정
   ├── BACK/                 ← 백엔드 (Spring Boot)
   │   ├── src/              ← 소스 코드
   │   ├── build.gradle      ← Gradle 빌드 설정
   │   └── ...               ← 기타 설정/리소스
   ├── FRONT/                ← 프론트엔드 (React + Next.js)
   │   ├── src/              ← 소스 코드
   │   ├── package.json      ← npm 의존성 관리
   │   └── ...               ← 기타 설정/리소스
   └── .github/
      └── workflows/
         └── deploy.yml    ← GitHub Actions 워크플로우 파일

   ```


8. 실행 디렉토리 생성 확인
   ```bash 
   ubuntu@ip-172-31-43-195:~/app/back/build/libs$ ls
   BOOT-INF  app.jar  app.tar.gz  back  back-0.0.1-SNAPSHOT.jar  uploads
   ```
   ```bash
   sudo chmod 755 /home/ubuntu
   sudo chmod 755 /home/ubuntu/app
   sudo chmod 644 /home/ubuntu/app/back/build/libs/uploads/* 
   ```
 
9. Oracle XE 컨테이너 실행
   ```bash
    docker run -d --name oracle-xe  -p 1521:1521 -p 5500:5500   -e ORACLE_PASSWORD=oracle  gvenzl/oracle-xe:11
   ```
10. 접속확인
   ```bash    
   docker logs -f oracle-xe | grep "DATABASE IS READY TO USE"
   docker exec -it oracle-xe  sqlplus system/oracle@XE

   CREATE USER scott IDENTIFIED BY tiger;
   GRANT CONNECT, RESOURCE TO scott;
   exit;

   docker exec -it oracle-xe sqlplus scott/tiger@XE
   ```
 

11. Docker Redis
  ```bash 
  docker run -d --name redis   -p 6379:6379   --restart=always   redis:7
  ```
12. 컨테이너 상태 확인
   ```bash
   docker ps
   ```
   → `redis` 컨테이너가 `Up` 상태인지, `PORTS`에 `0.0.0.0:6379->6379/tcp`가 표시되는지 확인하세요.

13. 컨테이너 내부 접속 후 ping 테스트
   ```bash
   docker exec -it redis redis-cli ping
   ```
   → `PONG` 이 나오면 정상 실행 중입니다.

 14. EC2 자체에서 자동 실행 설정
 ```bash
 docker update --restart=always oracle-xe 
 docker update --restart=always redis
```

 15. oracle 11은 화면에 뜨기까지 2~3분 , 최대 5분까지 걸림
 ```bash
 docker logs -f oracle-xe
 ```

 16. swap
 ```bash
  sudo fallocate -l 2G /swapfile
  sudo chmod 600 /swapfile
  sudo mkswap /swapfile
  sudo swapon /swapfile
  echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
  free -h
 ```
 docker restart oracle-xe
 docker logs -f oracle-xe

```bash
   #필기 - 메모리 부족 시 사용
  sudo fallocate -l 2G /swapfile  #2GB 파일 생성(RAM 대용)
  sudo chmod 600 /swapfile    # 권한 유저 rw- --- ---
  sudo mkswap /swapfile    # 스왑 초기화
  sudo swapon /swapfile    # 스왑 활성화
  echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab      # 설정파일 끝에 추가
  free -h      # 메모리 확인
```
 

■ 7. IAM 사용자/역할 생성

1. IAM 콘솔 → 사용자 추가  
2. 권한 정책: `AmazonEC2FullAccess`, `AmazonECS_FullAccess`, `AmazonECRFullAccess`  
3. Access Key / Secret Key 발급  
4. GitHub Secrets에 저장  

- `AmazonEC2FullAccess` -> EC2 인스턴스 관리
- `AmazonECS_FullAccess`  -> ECS/Faaragate 서비스 관리
- `AmazonEC2ContainerRegistryFullAccess`  -> Docker 이미지 push/pull 

```
Access Key *****
Secret Key ********
```

■ 8. Github Secrets 설정
>CI/CD
 ci(지속적 통합 통합)
   - 공용 저장소에 자주 병합(깃허브 작성)
   - 자동 빌드/테스트를 통해 버그 조기에 발견
 cd(지속적 제공/배포)
   - 자동으로 프로덕션 환경에 배포 


```
Name: EC2_HOST
Secret: ****
Name: EC2_USER
Secret: ubuntu

Name: EC2_SSH_KEY
Secret: .pem 파일 내용을 그대로 붙여넣기

Name: AWS_ACCESS_KEY_ID
Secret: 111

Name: AWS_SECRET_ACCESS_KEY
Secret: 111

Name: AWS_REGION
Secret: 111

Name: AWS_ACCOUNT_ID
Secret: 111

Name: ECR_REPO
Secret:111
```

```
Name: DB_USERNAME
Secret: SCOTT

Name: DB_PASSWORD
Secret: tiger 

Name: JWT_SECRET
Secret: =this-is-a-very-long-random-secret-key-64chars-minimum-1234567890!@#$%^&*() 

Name: GOOGLE_CLIENT_ID
Secret:1111
Name: GOOGLE_CLIENT_SECRET
Secret: 1111
Name: KAKAO_CLIENT_ID 
Secret:11111

Name: NAVER_CLIENT_ID
Secret: 1111

Name: NAVER_CLIENT_SECRET
Secret:1111
```

```
# 서버 재시작 시 교체 필요
Name: NEXT_PUBLIC_API_BASE_URL
Secret: http://54.206.106.20
```

■9. Git Actions 워크플로우 연결

0. back/front 코드 수정
*서버 재시작 시 주소 다시 받아오기
1) ssh -i "thejoa703.pem" ubuntu@ec2-13-236-66-10.ap-southeast-2.compute.amazonaws.com
2) 13.236.66.10

*백, 프론트 깃허브 secret 주소 변경


1. .github/workflows/deploy.yml
2. 빌드
```
git add .
git commit -m "test deploy"
git push origin main
```
3. 외부테스트 :  http://13.124.236.156


```
Run ./gradlew clean build -x test
  ./gradlew clean build -x test
  shell: /usr/bin/bash -e {0}
  env:
    JAVA_HOME: /opt/hostedtoolcache/Java_Temurin-Hotspot_jdk/17.0.18-8/x64
    JAVA_HOME_17_X64: /opt/hostedtoolcache/Java_Temurin-Hotspot_jdk/17.0.18-8/x64
Error: Unable to access jarfile /home/runner/work/thejoa703-iam/thejoa703-iam/back/gradle/wrapper/gradle-wrapper.jar
Error: Process completed with exit code 1.
```
> ./gradlew clean build -x test (back에서 입력)


*무한증식 제거(위치-back)
```
sudo rm -rf app
sudo rm -rf app
```

## Part003. ci/cd

```
thejoa703/                ← 깃허브 저장소 루트
├── .git                  ← Git 저장소 메타데이터
├── .gitignore            ← 불필요한 파일 제외 설정
├── BACK/                 ← 백엔드 (Spring Boot)
│   ├── src/              ← 소스 코드
│   ├── build.gradle      ← Gradle 빌드 설정
│   └── ...               ← 기타 설정/리소스
├── FRONT/                ← 프론트엔드 (React + Next.js)
│   ├── src/              ← 소스 코드
│   ├── package.json      ← npm 의존성 관리
│   └── ...               ← 기타 설정/리소스
└── .github/
    └── workflows/
        └── deploy.yml    ← GitHub Actions 워크플로우 파일
```git 